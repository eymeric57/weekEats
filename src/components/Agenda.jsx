import {useNavigation} from '@react-navigation/native';
import React, {useState, useCallback, useEffect} from 'react';
import {View, Text, StyleSheet, Pressable} from 'react-native';
import {Agenda} from 'react-native-calendars';
import {useDispatch, useSelector} from 'react-redux';
import {selectPlanningData} from '../redux/planing/PlaningSelector';
import {fetchPlanningDetail} from '../redux/planing/PlaningSlice';
import axios from 'axios';
import {API_URL} from '../constants/apiConstants';
import {AuthContext} from '../contexts/AuthContext';

const AutoGeneratedAgenda = () => {
  const navigation = useNavigation();
  const userId = AuthContext.user ? AuthContext.user.id : null;
  const dispatch = useDispatch();
  const {planningDetail, loading} = useSelector(selectPlanningData);
  const [items, setItems] = useState({});
  const [isLoading, setIsLoading] = useState(false);

  const timeToString = time => {
    const date = new Date(time);
    return date.toISOString().split('T')[0];
  };

  useEffect(() => {
    if (userId) {
      dispatch(fetchPlanningDetail(userId));
    }
  }, [dispatch, userId]);

  const getMealTimeOfDay = type => {
    if (!type || typeof type !== 'string') {
      console.log('Type invalide reçu:', type);
      return null;
    }

    const normalizedType = type.trim().toLowerCase();

    if (normalizedType.includes('petit') || normalizedType.includes('matin')) {
      return 'matin';
    }
    if (
      normalizedType.includes('midi') ||
      normalizedType.includes('dejeuner') ||
      normalizedType.includes('déjeuner')
    ) {
      return 'midi';
    }
    if (
      normalizedType.includes('soir') ||
      normalizedType.includes('diner') ||
      normalizedType.includes('dîner')
    ) {
      return 'soir';
    }

    console.log('Type non reconnu:', type);
    return null;
  };

  const loadItems = useCallback(
    async day => {
      setIsLoading(true);
      const newItems = {};

      try {
        if (planningDetail?.['hydra:member']) {
          // Créer un objet pour regrouper les repas par date
          const planningsByDate = {};

          // Regrouper tous les plannings par date
          for (const planning of planningDetail['hydra:member']) {
            const strTime = planning.date.split('T')[0];

            if (!planningsByDate[strTime]) {
              planningsByDate[strTime] = {
                id: planning.id,
                date: strTime,
                mealsByTimeOfDay: {
                  matin: [],
                  midi: [],
                  soir: [],
                },
                types: [],
                meals: [],
              };
            }

            // Ajouter les types et repas au planning de cette date
            planningsByDate[strTime].types.push(...planning.types);
            planningsByDate[strTime].meals.push(...planning.meals);
          }

          // Traiter chaque date
          for (const [strTime, planning] of Object.entries(planningsByDate)) {
            try {
              // Récupération des types
              const typePromises = planning.types.map(async typeUrl => {
                try {
                  const id = typeUrl.split('/').pop();
                  const response = await axios.get(`${API_URL}/types/${id}`);
                  return response.data?.label;
                } catch (error) {
                  console.error('Erreur récupération type:', error);
                  return null;
                }
              });

              // Récupération des repas
              const mealPromises = planning.meals.map(async mealUrl => {
                try {
                  const id = mealUrl.split('/').pop();
                  const response = await axios.get(`${API_URL}/meals/${id}`);
                  return response.data?.label;
                } catch (error) {
                  console.error('Erreur récupération repas:', error);
                  return null;
                }
              });

              // Attendre toutes les réponses
              const [types, meals] = await Promise.all([
                Promise.all(typePromises),
                Promise.all(mealPromises),
              ]);

              // Association des repas aux moments de la journée
              types.forEach((type, index) => {
                if (type && meals[index]) {
                  const timeOfDay = getMealTimeOfDay(type);
                  if (timeOfDay) {
                    planningsByDate[strTime].mealsByTimeOfDay[timeOfDay].push(
                      meals[index],
                    );
                  }
                }
              });

              // Ajouter le planning traité aux items
              newItems[strTime] = [planningsByDate[strTime]];
            } catch (error) {
              console.error('Erreur lors du traitement du planning:', error);
            }
          }
        }

        // Ajouter les jours vides
        const start = new Date(day.timestamp - 15 * 24 * 60 * 60 * 1000);
        const end = new Date(day.timestamp + 85 * 24 * 60 * 60 * 1000);

        for (let d = start; d <= end; d.setDate(d.getDate() + 1)) {
          const strTime = timeToString(d);
          if (!newItems[strTime]) {
            newItems[strTime] = [
              {
                name: 'Pas de repas prévu !',
                mealsByTimeOfDay: {matin: [], midi: [], soir: []},
                id: null,
                date: strTime,
              },
            ];
          }
        }

        setItems(newItems);
      } catch (error) {
        console.error('Erreur générale:', error);
      } finally {
        setIsLoading(false);
      }
    },
    [planningDetail],
  );

  useEffect(() => {
    if (planningDetail) {
      loadItems({timestamp: Date.now()});
    }
  }, [planningDetail, loadItems]);

  const renderItem = useCallback(
    item => {
      if (!item?.mealsByTimeOfDay) {
        return (
          <View style={styles.item}>
            <Text style={styles.noMealText}>Pas de repas prévu</Text>
          </View>
        );
      }

      const noMealPlanned =
        !item.mealsByTimeOfDay.matin.length &&
        !item.mealsByTimeOfDay.midi.length &&
        !item.mealsByTimeOfDay.soir.length;

      return (
        <Pressable
          onPress={() => navigation.navigate('MealPlannerScreen', {item})}>
          <View style={styles.item}>
            <View style={styles.itemContent}>
              {noMealPlanned ? (
                <Text style={styles.noMealText}>Pas de repas prévu</Text>
              ) : (
                <>
                  {item.mealsByTimeOfDay.matin.length > 0 && (
                    <>
                      <Text style={styles.mealTypeHeader}>Matin</Text>
                      {item.mealsByTimeOfDay.matin.map((meal, index) => (
                        <Text key={`matin-${index}`} style={styles.mealName}>
                          {meal}
                        </Text>
                      ))}
                    </>
                  )}

                  {item.mealsByTimeOfDay.midi.length > 0 && (
                    <>
                      <Text style={styles.mealTypeHeader}>Midi</Text>
                      {item.mealsByTimeOfDay.midi.map((meal, index) => (
                        <Text key={`midi-${index}`} style={styles.mealName}>
                          {meal}
                        </Text>
                      ))}
                    </>
                  )}

                  {item.mealsByTimeOfDay.soir.length > 0 && (
                    <>
                      <Text style={styles.mealTypeHeader}>Soir</Text>
                      {item.mealsByTimeOfDay.soir.map((meal, index) => (
                        <Text key={`soir-${index}`} style={styles.mealName}>
                          {meal}
                        </Text>
                      ))}
                    </>
                  )}
                </>
              )}
            </View>
          </View>
        </Pressable>
      );
    },
    [navigation],
  );

  return (
    <Agenda
      items={items}
      loadItemsForMonth={loadItems}
      renderItem={renderItem}
      renderEmptyDate={() => (
        <Pressable onPress={() => navigation.navigate('MealPlannerScreen', {})}>
          <View style={styles.emptyDate} />
        </Pressable>
      )}
      rowHasChanged={(r1, r2) => r1.id !== r2.id}
      showClosingKnob={true}
      pastScrollRange={20}
      futureScrollRange={20}
      hideKnob={false}
      minDate={new Date().toISOString().split('T')[0]}
      theme={{
        agendaDayNumColor: '#639067',
        agendaDayTextColor: '#639067',
        agendaTodayColor: '#639067',
        agendaKnobColor: '#4ac4f7',
      }}
    />
  );
};

const styles = StyleSheet.create({
  item: {
    width: 306,
    minHeight: 100,
    backgroundColor: '#efefef',
    borderRadius: 21,
    shadowColor: '#000',
    shadowOffset: {width: 0, height: 2},
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    marginRight: 10,
    marginTop: 17,
    marginBottom: 17,
  },
  itemContent: {
    padding: 16,
    flex: 1,
  },
  mealTypeHeader: {
    backgroundColor: '#D9D9D9',
    padding: 1,
    paddingLeft: 4,
    borderRadius: 10,
    marginTop: 8,
  },
  emptyItem: {
    height: 15,
    flex: 1,
    paddingTop: 30,
  },
  emptyDate: {
    height: 15,
    flex: 1,
    paddingTop: 30,
  },
  dateText: {
    fontSize: 12,
    color: '#7c7c7c',
    marginBottom: 4,
  },
  itemText: {
    fontSize: 16,
    color: 'black',
    fontWeight: 'bold',
    marginBottom: 8,
  },
  mealTypeContainer: {
    width: '100%',
    marginBottom: 0,
  },
  mealType: {
    backgroundColor: '#d9d9d9',
    color: '#7c7c7c',
    fontSize: 12,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 8,
    marginRight: 4,
    marginBottom: 1,
  },
  mealName: {
    fontSize: 12,
    color: 'black',
    margin: 4,
  },
  noMealText: {
    fontSize: 16,
    color: '#FF0000',
    textAlign: 'center',
    fontWeight: 'bold',
  },
});

export default AutoGeneratedAgenda;
