import { useNavigation, useRoute } from '@react-navigation/native';
import React, { useState, useCallback, useEffect } from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { Agenda, LocaleConfig } from 'react-native-calendars';
import { useDispatch, useSelector } from 'react-redux';
import { selectPlanningData } from '../redux/planing/PlaningSelector';
import { fetchPlanningDetail } from '../redux/planing/PlaningSlice';
import axios from 'axios';
import { API_URL } from '../constants/apiConstants';

// Configuration de la locale française
LocaleConfig.locales['fr'] = {
  monthNames: [
    'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
    'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre',
  ],
  monthNamesShort: [
    'Janv.', 'Févr.', 'Mars', 'Avril', 'Mai', 'Juin',
    'Juil.', 'Août', 'Sept.', 'Oct.', 'Nov.', 'Déc.',
  ],
  dayNames: [
    'Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi',
    'Vendredi', 'Samedi',
  ],
  dayNamesShort: ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 
                  'Ven.', 'Sam.'],
  today: "Aujourd'hui",
};
LocaleConfig.defaultLocale = 'fr';

const AutoGeneratedAgenda = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { userId } = route.params || {};
  const dispatch = useDispatch();
  const { planningDetail } = useSelector(selectPlanningData);
  const [items, setItems] = useState({});

  // Récupérer les détails du planning pour l'utilisateur
  useEffect(() => {
    if (userId) {
      dispatch(fetchPlanningDetail(userId));
    }
  }, [dispatch, userId]);

  // Charger les éléments dans l'agenda
  const loadItems = useCallback(
    async day => {
      const newItems = {};

      // Vérifier si planningDetail est défini et contient des membres
      if (planningDetail && planningDetail['hydra:member']) {
        for (const planning of planningDetail['hydra:member']) {
          const strTime = planning.date.split('T')[0]; // Obtenir la date au format YYYY-MM-DD

          if (!newItems[strTime]) {
            newItems[strTime] = [];
          }

          const mealLabels = Array.isArray(planning.meals)
            ? planning.meals.map(meal => meal.label) // Extraire les labels des repas
            : []; // Si meals n'est pas un tableau, initialisez à un tableau vide

          const typeIds = planning.types.map(type => type.split('/').pop()); // Récupérer les IDs des types
          const mealIds = planning.meals.map(meal => meal.split('/').pop()); // Récupérer les IDs des repas

          // Fonction pour récupérer les détails des types
          const fetchTypeDetails = async ids => {
            const labels = [];
            for (const id of ids) {
              try {
                const response = await axios.get(`${API_URL}/types/${id}`);
                labels.push(response.data.label); // Ajoutez le label à votre tableau
              } catch (error) {
                console.log(`Erreur lors de la sélection des détails du type ${id}: ${error}`);
              }
            }
            return labels; // Retournez le tableau des labels
          };

          // Fonction pour récupérer les détails des repas
          const fetchMealDetails = async ids => {
            const labels = [];
            for (const id of ids) {
              try {
                const response = await axios.get(`${API_URL}/meals/${id}`);
                labels.push(response.data.labelMeal); // Ajoutez le label du repas à votre tableau
              } catch (error) {
                console.log(`Erreur lors de la sélection des détails du repas ${id}: ${error}`);
              }
            }
            return labels; // Retournez le tableau des labels de repas
          };

          // Récupérer les labels des types et des repas
          const typeLabels = await fetchTypeDetails(typeIds);
          const mealLabelsFetched = await fetchMealDetails(mealIds);

          // Ajouter l'élément à newItems avec les labels récupérés
          newItems[strTime].push({
            name: `Planning ${planning.id}`, // Nom de l'élément
            meals: mealLabelsFetched,
            types: typeLabels,
          });
        }
      }

      // Générer des jours sans données avec un message par défaut
      for (let i = -15; i < 45; i++) {
        const time = day.timestamp + i * 24 * 60 * 60 * 1000;
        const strTime = timeToString(time);

        if (!newItems[strTime]) {
          newItems[strTime] = [
            {
              name: "Pas de repas prévu !", // Message par défaut
            },
          ];
        }
      }

      setItems(newItems);
    },
    [planningDetail],
  );

  // Charger les éléments à l'initialisation
  useEffect(() => {
    loadItems({ timestamp: Date.now() });
  }, [loadItems]);

  // Obtenir la date actuelle pour minDate
  const today = new Date();

  // Rendre chaque élément de l'agenda
  const renderItem = item => {
    const date = new Date(item.timestamp);
    
    return (
      <Pressable
        onPress={() =>
          navigation.navigate('MealPlannerScreen', { userId: userId, planningId: item.id, date: date.toISOString() })
        }>
        <View style={styles.item}>
          <View style={styles.row}>
            <View style={styles.itemTextContainer}>
              <Text style={styles.itemText}>{item.name}</Text>
              <Text>Repas: {item.meals ? item.meals.length : 0}</Text>
              <Text>
                Types:{' '}
                {item.types && item.types.length > 0 ? item.types.join(', ') : "Aucun"}
              </Text>
            </View>
          </View>
        </View>
      </Pressable>
    );
  };

  return (
    <Agenda
      items={items}
      loadItemsForMonth={loadItems}
      renderItem={renderItem}
      rowHasChanged={(r1, r2) => r1.name !== r2.name}
      showClosingKnob={true}
      pastScrollRange={50}
      futureScrollRange={50}
      hideKnob={false}
      minDate={today.toISOString().split('T')[0]} // Définir la date minimale
      theme={{
        agendaDayNumColor: '#639067',
        agendaDayTextColor: '#639067',
        agendaTodayColor: '#639067',
        agendaKnobColor: '#4ac4f7',
        agendaDayBackgroundColor: '#f1f3f4',
        agendaDayHeaderRightBorderColor: '#dadce0',
        agendaDayHeaderRightBorderWidth: 1,
      }}
    />
  );
};

const timeToString = time => {
  const date = new Date(time);
  return date.toISOString().split('T')[0];
};

const styles = StyleSheet.create({
  item: {
    backgroundColor: 'white',
    flex: 1,
    borderRadius: 5,
    padding: 10,
    marginRight: 10,
    marginTop: 17,
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  itemTextContainer:{
     flexDirection:'column', 
     alignItems:'flex-start'
   },
   itemText:{
     color:'#888', 
     fontSize:19 
   },
   emptyDate:{
     height:15,
     flex:1,
     paddingTop:30 
   },
});

export default AutoGeneratedAgenda;