import {useNavigation, useRoute} from '@react-navigation/native';
import React, {useState, useCallback, useEffect} from 'react';
import {View, Text, StyleSheet, Pressable} from 'react-native';
import {Agenda, LocaleConfig} from 'react-native-calendars';
import {useDispatch, useSelector} from 'react-redux';
import {selectPlanningData} from '../redux/planing/PlaningSelector';
import {fetchPlanningDetail} from '../redux/planing/PlaningSlice';
import axios from 'axios';
import {API_URL} from '../constants/apiConstants';
import Loader from './loader/Loader';

<LocaleConfig />;

const AutoGeneratedAgenda = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const {userId} = route.params || {};
  const dispatch = useDispatch();
  const {planningDetail, loading} = useSelector(selectPlanningData);
  const [items, setItems] = useState({});
  // const [isLoading, setIsLoading] = useState(false);

  const timeToString = time => {
    const date = new Date(time);
    return date.toISOString().split('T')[0];
  };

  // Récupérer les détails du planning pour l'utilisateur
  useEffect(() => {
    if (userId) {
      dispatch(fetchPlanningDetail(userId));
    }
  }, [dispatch, userId]);

  useEffect(() => {
    loadItems({timestamp: Date.now()});
  }, [loadItems]);

  // Charger les éléments dans l'agenda
  const loadItems = useCallback(
    async day => {
      const newItems = {};

      try {
        if (planningDetail && planningDetail['hydra:member']) {
          for (const planning of planningDetail['hydra:member']) {
            const strTime = planning.date.split('T')[0]; // Obtenir la date au format YYYY-MM-DD

            if (!newItems[strTime]) {
              newItems[strTime] = [
                {
                  mealsByTimeOfDay: {
                    matin: [],
                    midi: [],
                    soir: [],
                  },
                  id: planning.id, // Ajoutez l'ID ici
                  date: strTime, // Ajoutez la date ici
                  name: 'Repas prévu', // Ajoutez un nom par défaut
                },
              ];
            }

            const typeIds = planning.types.map(type => type.split('/').pop()); // Récupérer les IDs des types
            const mealIds = planning.meals.map(meal => meal.split('/').pop()); // Récupérer les IDs des repas

            // Fonction pour récupérer les détails des types
            const fetchTypeDetails = async ids => {
              const labels = [];
              for (const id of ids) {
                try {
                  const response = await axios.get(`${API_URL}/types/${id}`);
                  labels.push(response.data.label);
                } catch (error) {
                  console.log(
                    `Erreur lors de la récupération du type ${id}: ${error}`,
                  );
                }
              }
              return labels;
            };

            // Fonction pour récupérer les détails des repas
            const fetchMealDetails = async ids => {
              const labels = [];
              for (const id of ids) {
                try {
                  const response = await axios.get(`${API_URL}/meals/${id}`);
                  labels.push(response.data.label);
                } catch (error) {
                  console.log(
                    `Erreur lors de la récupération du repas ${id}: ${error}`,
                  );
                }
              }
              return labels;
            };

            // Récupérer les labels des types et des repas
            const typeLabels = await fetchTypeDetails(typeIds);
            const mealLabelsFetched = await fetchMealDetails(mealIds);

            // Regrouper les repas par moment de la journée
            const mealsByTimeOfDay = {
              matin: [],
              midi: [],
              soir: [],
            };

            // Associer les repas au moment de la journée basé sur le type
            typeLabels.forEach((type, index) => {
              if (
                type.toLowerCase().includes('petit-déjeuner') ||
                type.toLowerCase().includes('matin')
              ) {
                mealsByTimeOfDay.matin.push(mealLabelsFetched[index]);
              } else if (
                type.toLowerCase().includes('déjeuner') ||
                type.toLowerCase().includes('midi')
              ) {
                mealsByTimeOfDay.midi.push(mealLabelsFetched[index]);
              } else if (
                type.toLowerCase().includes('dîner') ||
                type.toLowerCase().includes('soir')
              ) {
                mealsByTimeOfDay.soir.push(mealLabelsFetched[index]);
              }
            });

            // Ajouter les repas à la journée correspondante
            newItems[strTime][0].mealsByTimeOfDay.matin.push(
              ...mealsByTimeOfDay.matin,
            );
            newItems[strTime][0].mealsByTimeOfDay.midi.push(
              ...mealsByTimeOfDay.midi,
            );
            newItems[strTime][0].mealsByTimeOfDay.soir.push(
              ...mealsByTimeOfDay.soir,
            );
          }
        }

        // Ajouter des jours sans repas prévus avec un message par défaut
        for (let i = -15; i < 85; i++) {
          const time = day.timestamp + i * 24 * 60 * 60 * 1000;
          const strTime = timeToString(time);

          if (!newItems[strTime]) {
            newItems[strTime] = [
              {
                name: 'Pas de repas prévu !',
                mealsByTimeOfDay: {
                  matin: [],
                  midi: [],
                  soir: [],
                },
                id: null,
                date: strTime,
              },
            ];
          }
        }

        setItems(newItems);
      
      } catch (error) {
        console.error('Erreur lors du chargement des éléments:', error);
      }
    },
    [planningDetail],
  );

  // Obtenir la date actuelle pour minDate
  const today = new Date();

  // Rendre chaque élément de l'agenda
  const renderItem = item => {
    const noMealPlanned =
      !item.mealsByTimeOfDay.matin.length &&
      !item.mealsByTimeOfDay.midi.length &&
      !item.mealsByTimeOfDay.soir.length;

    return (
      <Pressable
        onPress={() => {
          console.log('Press detected, navigating to MealPlannerScreen');
          navigation.navigate('MealPlannerScreen', {
            userId: userId,
            planningId: item.id, // Cela peut être null
            date: item.date,
          });
        }}>
        <View style={styles.item}>
          <View style={styles.itemContent}>
            {noMealPlanned ? (
              <Text style={styles.noMealText}>Pas de repas prévu</Text>
            ) : (
              <>
                {/* Repas pour le matin */}
                {item.mealsByTimeOfDay.matin.length > 0 && (
                  <>
                    <Text style={styles.mealTypeHeader}>Matin</Text>
                    <Text style={styles.mealName}>
                      {item.mealsByTimeOfDay.matin.join(', ')}
                    </Text>
                  </>
                )}

                {/* Repas pour midi */}
                {item.mealsByTimeOfDay.midi.length > 0 && (
                  <>
                    <Text style={styles.mealTypeHeader}>Midi</Text>
                    <Text style={styles.mealName}>
                       {item.mealsByTimeOfDay.matin.join(', ')}
                    </Text>
                  </>
                )}

                {/* Repas pour le soir */}
                {item.mealsByTimeOfDay.soir.length > 0 && (
                  <>
                    <Text style={styles.mealTypeHeader}>Soir</Text>
                    <Text style={styles.mealName}>
                      {item.mealsByTimeOfDay.soir.join(', ')}
                    </Text>
                  </>
                )}
              </>
            )}
          </View>
        </View>
      </Pressable>
    );
  };

  return (
    <Agenda
      items={items}
      loadItemsForMonth={loadItems}
      renderItem={renderItem}
      renderEmptyDate={() => (
        <Pressable
          onPress={() => {
            navigation.navigate('MealPlannerScreen', {});
          }}></Pressable>
      )}
      rowHasChanged={(r1, r2) => r1.name !== r2.name}
      showClosingKnob={true}
      pastScrollRange={50}
      futureScrollRange={50}
      hideKnob={false}
      minDate={today.toISOString().split('T')[0]} // Définir la date minimale
      theme={{
        agendaDayNumColor: '#639067',
        agendaDayTextColor: '#639067',
        agendaTodayColor: '#639067',
        agendaKnobColor: '#4ac4f7',
      }}
    />
  );
};

const styles = StyleSheet.create({
  item: {
    width: 306,
    minHeight: 100, // Hauteur minimale
    backgroundColor: '#efefef',
    borderRadius: 21,
    shadowColor: '#000',
    shadowOffset: {width: 0, height: 2},
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    marginRight: 10,
    marginTop: 17,
    marginBottom: 17, // Ajout d'une marge en bas
  },
  itemContent: {
    padding: 16,
    flex: 1, // Permet au contenu de s'étendre
  },
  mealTypeHeader: {
    backgroundColor: '#D9D9D9',
    padding: 1,
    paddingLeft: 4,
    borderRadius: 10,
  },
  emptyItem: {
    height: 15,
    flex: 1,
    paddingTop: 30,
  },
  emptyDate: {
    height: 15,
    flex: 1,
    paddingTop: 30,
  },
  dateText: {
    fontSize: 12,
    color: '#7c7c7c',
    marginBottom: 4,
  },
  itemText: {
    fontSize: 16,
    color: 'black',
    fontWeight: 'bold',
    marginBottom: 8,
  },
  mealTypeContainer: {
    width: '100%',
    marginBottom: 0,
  },
  mealType: {
    backgroundColor: '#d9d9d9',
    color: '#7c7c7c',
    fontSize: 12,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 8,
    marginRight: 4,
    marginBottom: 1,
  },
  mealName: {
    display: 'flex',
    flexDirection: 'row',
    justifyContent: 'space-between',
    fontSize: 12,
    color: 'black',
    margin: 4,
  },
  noMealText: {
    fontSize: 16,
    color: '#7c7c7c',
    textAlign: 'center',
    fontWeight: 'bold',
  },
});

export default AutoGeneratedAgenda;
