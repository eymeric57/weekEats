import React, {useState, useCallback, useEffect} from 'react';
import {
  View,
  Text,
  Pressable,
  ScrollView,
  TouchableOpacity,
} from 'react-native';
import {useNavigation, useRoute} from '@react-navigation/native';
import Icon from 'react-native-vector-icons/Entypo';
import {PanGestureHandler, RefreshControl} from 'react-native-gesture-handler';
import {selectPlanningData} from '../redux/planing/PlaningSelector';
import {useSelector} from 'react-redux';
import axios from 'axios';
import {API_URL} from '../constants/apiConstants';

// import useMealsDetails from '../hooks/useMealsDetails';

const AutoGeneratedCalendar = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const {userId} = route.params || {};
  const [items, setItems] = useState({});
  const [currentDate, setCurrentDate] = useState(new Date());
  const [refreshing, setRefreshing] = React.useState(false);
  const [gestureHandled, setGestureHandled] = useState(false);
  const itemsArray = Object.entries(items);
  const {planningDetail, loading} = useSelector(selectPlanningData);
  // const {fetchTypeDetails, fetchMealDetails} = useMealsDetails(planningDetail.type.id);

  useEffect(() => {
    loadItems(currentDate);
  }, [ currentDate]);



  const loadItems = useCallback(async (date) => {
    setItems({});
    const newItems = {};

    if (planningDetail && planningDetail['hydra:member']) {
      for (const planning of planningDetail['hydra:member']) {
        const strTime = planning.date.split('T')[0]; // Obtenir la date au format YYYY-MM-DD

        if (!newItems[strTime]) {
          newItems[strTime] = [
            {
              mealsByTimeOfDay: {
                matin: [],
                midi: [],
                soir: [],
              },
              id: planning.id, // Ajoutez l'ID ici
              date: strTime, // Ajoutez la date ici
              name: 'Repas prévu', // Ajoutez un nom par défaut
            },
          ];
        }

        const typeIds = planning.types.map(type => type.split('/').pop()); // Récupérer les IDs des types

        const mealIds = planning.meals.map(meal => meal.split('/').pop()); // Récupérer les IDs des repas

        // Fonction pour récupérer les détails des types
        const fetchTypeDetails = async ids => {
          const labels = [];
          for (const id of ids) {
            try {
              const response = await axios.get(`${API_URL}/types/${id}`);
              labels.push(response.data.label);
            } catch (error) {
              console.log(
                `Erreur lors de la récupération du type ${id}: ${error}`,
              );
            }
          }
          return labels;
        };

        // Fonction pour récupérer les détails des repas
        const fetchMealDetails = async ids => {
          const labels = [];
          for (const id of ids) {
            try {
              const response = await axios.get(`${API_URL}/meals/${id}`);
              labels.push(response.data.label);
            } catch (error) {
              console.log(
                `Erreur lors de la récupération du repas ${id}: ${error}`,
              );
            }
          }
          return labels;
        };

        // Récupérer les labels des types et des repas
        const typeLabels = await fetchTypeDetails(typeIds);
        const mealLabelsFetched = await fetchMealDetails(mealIds);

        // Regrouper les repas par moment de la journée
        const mealsByTimeOfDay = {
          matin: [],
          midi: [],
          soir: [],
        };

        // Associer les repas au moment de la journée basé sur le type
        typeLabels.forEach((type, index) => {
          if (
            type.toLowerCase().includes('petit-déjeuner') ||
            type.toLowerCase().includes('matin')
          ) {
            mealsByTimeOfDay.matin.push(mealLabelsFetched[index]);
          } else if (
            type.toLowerCase().includes('déjeuner') ||
            type.toLowerCase().includes('midi')
          ) {
            mealsByTimeOfDay.midi.push(mealLabelsFetched[index]);
          } else if (
            type.toLowerCase().includes('dîner') ||
            type.toLowerCase().includes('soir')
          ) {
            mealsByTimeOfDay.soir.push(mealLabelsFetched[index]);
          }
        });

        // Ajouter les repas à la journée correspondante
        newItems[strTime][0].mealsByTimeOfDay.matin.push(
          ...mealsByTimeOfDay.matin,
        );
        newItems[strTime][0].mealsByTimeOfDay.midi.push(
          ...mealsByTimeOfDay.midi,
        );
        newItems[strTime][0].mealsByTimeOfDay.soir.push(
          ...mealsByTimeOfDay.soir,
        );
      }
    }
    const todayStr = timeToString(new Date());

    const startDate = new Date();
     for (let i = 0; i < 8; i++) {
    const time = startDate.getTime() + i * 24 * 60 * 60 * 1000;
    const strTime = timeToString(time);
    if (!newItems[strTime]) {
      newItems[strTime] = [
        {
          name: 'Pas de repas prévu !',
          mealsByTimeOfDay: {
            matin: [],
            midi: [],
            soir: [],
          },
          id: null,
          date: strTime,
        },
      ];
    }
  }
  const sortedItemsArray = Object.entries(newItems).sort(([dateA], [dateB]) => {
    return new Date(dateA) - new Date(dateB);
  });

  const todayIndex = sortedItemsArray.findIndex(([dateKey]) => dateKey === todayStr);

  const reorderedItemsArray = [
    ...sortedItemsArray.slice(todayIndex), // Les jours à partir d'aujourd'hui
    ...sortedItemsArray.slice(0, todayIndex) // Les jours avant aujourd'hui (au cas où)
  ];

  setItems(Object.fromEntries(sortedItemsArray));
}, []);

  //-----------------Changement de date ------------
  const changeDays = increment => {
    const newDate = new Date(currentDate);
    newDate.setDate(newDate.getDate() + increment * 8);
    setCurrentDate(newDate);

     loadItems(newDate);
  };

  //--------------Formatage des dates -------------

  const formatDateRange = () => {
    const startDate = new Date(currentDate);
    const endDate = new Date(currentDate);
    endDate.setDate(endDate.getDate() + 7);
    return `${formatDateMonth(startDate)} - ${formatDateDay(endDate)}`;
  };
  const timeToString = time => {
    const date = new Date(time);
    return date.toISOString().split('T')[0];
  };
  const formatDate = dateString => {
    const date = new Date(dateString);
    const options = {weekday: 'short', day: 'numeric'};
    return date.toLocaleDateString('fr-FR', options);
  };
  const formatDateMonth = date => {
    const options = {day: 'numeric', month: 'short'};
    return date.toLocaleDateString('fr-FR', options);
  };
  const formatDateDay = dateDay => {
    const options = {day: 'numeric', month: 'short'};
    return dateDay.toLocaleDateString('fr-FR', options);
  };

  //---------------------------------------------

  //--------------- Gestes de balayage-------------

  const handleGestureEvent = ({nativeEvent}) => {
    if (!gestureHandled) {
      if (nativeEvent.translationX > 50) {
        changeDays(-1); // Balayage vers la droite
        setGestureHandled(true); // Bloque d'autres gestes jusqu'à la fin de celui-ci
      } else if (nativeEvent.translationX < -50) {
        changeDays(1); // Balayage vers la gauche
        setGestureHandled(true); // Bloque d'autres gestes jusqu'à la fin de celui-ci
      }
    }
  };

  const handleGestureEnd = ({nativeEvent}) => {
    // Si le geste est terminé (ex: STATE.END), on réinitialise le blocage
    if (nativeEvent.state === 5) {
      // 5 correspond à "State.END" dans react-native-gesture-handler
      setGestureHandled(false); // Réinitialise l'état après la fin du geste
    }
  };

  //-----------------------------------------------
  //------------------Rendu des Cards--------
  const renderItem = (item, date) => {
    const noMealPlanned =
      !item.mealsByTimeOfDay.matin.length &&
      !item.mealsByTimeOfDay.midi.length &&
      !item.mealsByTimeOfDay.soir.length;
    return (
      <Pressable
        style={styles.cardContainer}
        onPress={() =>
          navigation.navigate('MealPlannerScreen', {userId: userId, date: date})
        }>
        <View style={styles.item}>
          {noMealPlanned ? (
            <Text style={styles.noMealText}>Pas de repas prévu</Text>
          ) : (
            <>
              <Text style={styles.dateText}>{formatDate(date)}</Text>

              {item.mealsByTimeOfDay.matin.length > 0 && (
                <Text style={styles.itemText}>
                  {styles.mealName}
                  {item.mealsByTimeOfDay.matin.join(', ')}
                </Text>
              )}

              <View style={styles.border} />

              {item.mealsByTimeOfDay.midi.length > 0 && (
                <>
                  <Text style={styles.timeText}>
                    {' '}
                    {item.mealsByTimeOfDay.midi.join(', ')}
                  </Text>
                </>
              )}

              <View style={styles.border} />

              {item.mealsByTimeOfDay.matin.length > 0 && (
                <>
                  <Text style={styles.timeText}>
                    {' '}
                    {item.mealsByTimeOfDay.matin.join(', ')}
                  </Text>
                </>
              )}
            </>
          )}
        </View>
      </Pressable>
    );
  };

  //--------------- Refresh pour retrouver la page du jour ---------------
  const onRefresh = React.useCallback(() => {
    setRefreshing(true);

    setTimeout(() => {
      const today = new Date();
      setCurrentDate(today); // Réinitialisez currentDate à aujourd'hui
      // Rechargez les éléments pour la date d'aujourd'hui
      loadItems(today);
      setRefreshing(false);
    }, 1000);
  }, []);

  //--------------Rendu du composant----------------
  return (
    // <PanGestureHandler
    // onGestureEvent={handleGestureEvent}
    // onHandlerStateChange={handleGestureEnd}>
    <ScrollView
      style={styles.container}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
      }>
      <Text className="font-kaushan text-3xl text-[#639067] text-center p-5">
        Calendrier
      </Text>
      <View style={styles.centerContainer}>
        <View style={styles.monthContainer}>
          <TouchableOpacity
            onPress={() => changeDays(-1)}
            style={styles.monthButton}>
            <Icon name="triangle-left" size={24} color="white" />
          </TouchableOpacity>
          <View style={styles.monthTextContainer}>
            <Text style={styles.monthText}>{formatDateRange()}</Text>
          </View>
          <TouchableOpacity
            onPress={() => changeDays(1)}
            style={styles.monthButton}>
            <Icon name="triangle-right" size={24} color="white" />
          </TouchableOpacity>
        </View>
      </View>
      <View style={styles.grid}>
        {itemsArray.map(([dateKey, dateItems], index) => (
          <View key={dateKey} style={styles.column}>
            {renderItem(dateItems[0], dateKey)}
          </View>
        ))}
      </View>
    </ScrollView>
    // </PanGestureHandler>
  );
};

const styles = {
  container: {
    flex: 1,
    backgroundColor: '#ffffff',
  },
  monthContainer: {
    marginTop: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#639067',
    borderRadius: 40,
    paddingHorizontal: 2,
    paddingVertical: 3,
    width: '65%',
  },
  monthTextContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  monthButton: {
    padding: 9,
  },
  border: {
    width: '80%',
    alignSelf: 'center',
    height: 2,
    backgroundColor: '#639067',
    marginTop: 5,
  },
  monthText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
    textAlign: 'center',
  },
  centerContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    width: '100%',
  },
  grid: {
    flex: 1,
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    paddingHorizontal: 10,
    paddingTop: 10,
  },
  column: {
    width: '50%',
    paddingHorizontal: 10,
  },
  cardContainer: {
    flex: 1,
    marginTop: 20,
    marginBottom: 10,
    paddingVertical: 10,
  },
  item: {
    backgroundColor: '#EFEFEF',
    borderRadius: 8,
    borderColor: '#dcdcdc',
    borderWidth: 1,
    paddingVertical: 15,
    paddingHorizontal: 10,
    shadowColor: '#000',
    shadowOffset: {width: 0, height: 2},
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    flexGrow: 1,
  },
  dateText: {
    fontSize: 24,
    fontWeight: '900',
    color: '#639067',
    marginBottom: 10,
  },
  dateText: {
    fontSize: 24,
    fontWeight: '900',
    color: '#639067',
    marginBottom: 5,
    position: 'absolute',
    top: -20,
    left: 40,
  },

  itemText: {
    color: '#888',
    fontSize: 14,
    fontWeight: '500',
    flexWrap: 'wrap', // Permet au texte de passer à la ligne
  },
  border: {
    borderBottomWidth: 1,
    borderBottomColor: '#dcdcdc',
    marginVertical: 5,
  },
  timeText: {
    color: '#888',
    fontSize: 12,
    marginTop: 5,
  },
  scrollViewContent: {
    flexGrow: 1,
  },
  centerText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#639067',
    marginBottom: 10,
  },
};

export default AutoGeneratedCalendar;
